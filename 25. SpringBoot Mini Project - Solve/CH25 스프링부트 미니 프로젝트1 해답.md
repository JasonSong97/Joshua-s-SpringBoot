# CH25 스프링부트 미니프로젝트1 해답

#### 프로젝트 준비

https://github.com/codingspecialist/Springboot-MetaMall-Project.git

#### 프로젝트 완료

https://github.com/codingspecialist/Springboot-MetaMall-Project/tree/complete

#### API

![1](images/1.png)

```json
{
    "status": 200,
    "msg": "성공",
    "data": {
        "id": 4,
        "username": "cos",
        "email": "cos@nate.com",
        "role": "USER",
        "status": true,
        "createdAt": "2023-04-12T21:38:38.846382",
        "updatedAt": null
    }
}
```

![2](images/2.png)

```json
{
    "status": 200,
    "msg": "성공",
    "data": {
        "id": 2,
        "username": "seller",
        "email": "seller@nate.com",
        "role": "SELLER",
        "status": true,
        "createdAt": "2023-04-12T21:38:31.320519",
        "updatedAt": "2023-04-12T22:04:22.3401313"
    }
}
```

```text
Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJqd3RzdHVkeSIsInJvbGUiOiJTRUxMRVIiLCJpZCI6MiwiZXhwIjoxNjgxMzA4MjYyfQ.yFegUhrBvZx3lE69odY7aB2kz8H0ilSbnle_EExUGfr-3Ys5tjXmsMKfIlTso4CWCoK-IRlVVg6RgBpQvffn6g
```

![3](images/3.png)

```json
{
    "status": 200,
    "msg": "성공",
    "data": {
        "id": 1,
        "seller": {
            "id": 2,
            "username": "seller",
            "email": "seller@nate.com",
            "role": "SELLER",
            "status": true,
            "createdAt": "2023-04-12T21:38:31.320519",
            "updatedAt": "2023-04-12T22:04:22.340131"
        },
        "name": "딸기",
        "price": 2000,
        "qty": 50,
        "createdAt": "2023-04-12T22:04:59.7051025",
        "updatedAt": null
    }
}
```

![4](images/4.png)

```json
{
    "status": 200,
    "msg": "성공",
    "data": {
        "content": [
            {
                "id": 1,
                "seller": {
                    "id": 2,
                    "username": "seller",
                    "email": "seller@nate.com",
                    "role": "SELLER",
                    "status": true,
                    "createdAt": "2023-04-12T21:38:31.320519",
                    "updatedAt": "2023-04-12T22:04:22.340131"
                },
                "name": "딸기",
                "price": 2000,
                "qty": 50,
                "createdAt": "2023-04-12T22:04:59.705103",
                "updatedAt": null
            }
        ],
        "pageable": {
            "sort": {
                "empty": true,
                "sorted": false,
                "unsorted": true
            },
            "offset": 0,
            "pageNumber": 0,
            "pageSize": 10,
            "paged": true,
            "unpaged": false
        },
        "last": true,
        "totalPages": 1,
        "totalElements": 1,
        "size": 10,
        "number": 0,
        "sort": {
            "empty": true,
            "sorted": false,
            "unsorted": true
        },
        "first": true,
        "numberOfElements": 1,
        "empty": false
    }
}
```

![5](images/5.png)

```json
{
    "status": 200,
    "msg": "성공",
    "data": {
        "id": 1,
        "seller": {
            "id": 2,
            "username": "seller",
            "email": "seller@nate.com",
            "role": "SELLER",
            "status": true,
            "createdAt": "2023-04-12T21:38:31.320519",
            "updatedAt": "2023-04-12T22:04:22.340131"
        },
        "name": "딸기",
        "price": 2000,
        "qty": 50,
        "createdAt": "2023-04-12T22:04:59.705103",
        "updatedAt": null
    }
}
```

![6](images/6.png)

```json
{
    "status": 200,
    "msg": "성공",
    "data": {
        "id": 1,
        "seller": {
            "id": 2,
            "username": "seller",
            "email": "seller@nate.com",
            "role": "SELLER",
            "status": true,
            "createdAt": "2023-04-12T21:38:31.320519",
            "updatedAt": "2023-04-12T22:04:22.340131"
        },
        "name": "딸기수정",
        "price": 5000,
        "qty": 100,
        "createdAt": "2023-04-12T22:04:59.705103",
        "updatedAt": "2023-04-12T22:07:14.3531134"
    }
}
```

![7](images/7.png)

```json
{
    "status": 200,
    "msg": "성공",
    "data": null
}
```

![8](images/8.png)

```json
{
    "status": 200,
    "msg": "성공",
    "data": {
        "id": 1,
        "username": "ssar",
        "email": "ssar@nate.com",
        "role": "USER",
        "status": true,
        "createdAt": "2023-04-12T21:38:31.285822",
        "updatedAt": "2023-04-12T22:10:00.361921"
    }
}
```

```text
Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJqd3RzdHVkeSIsInJvbGUiOiJVU0VSIiwiaWQiOjEsImV4cCI6MTY4MTMwODYwMH0.wCC4xwqUMLaRdnd7BYtTxpSz_pPysJykcD9Axe9WsuxtTmHV1Hj6iuP2eKIHaBCTebTnUp09voYDJm3DjLl8og
```

![9](images/9.png)

```json
{
    "status": 200,
    "msg": "성공",
    "data": {
        "id": 1,
        "user": {
            "id": 1,
            "username": "ssar",
            "email": "ssar@nate.com",
            "role": "USER",
            "status": true,
            "createdAt": "2023-04-12T22:12:16.290459",
            "updatedAt": null
        },
        "orderProductList": [
            {
                "id": 1,
                "product": {
                    "id": 1,
                    "name": "딸기",
                    "price": 2000,
                    "qty": 45,
                    "createdAt": "2023-04-12T22:12:23.995651",
                    "updatedAt": "2023-04-12T22:12:34.0531871"
                },
                "count": 5,
                "orderPrice": 10000,
                "createdAt": "2023-04-12T22:12:34.0511866",
                "updatedAt": null
            },
            {
                "id": 2,
                "product": {
                    "id": 2,
                    "name": "바나나",
                    "price": 2000,
                    "qty": 48,
                    "createdAt": "2023-04-12T22:12:28.289963",
                    "updatedAt": "2023-04-12T22:12:34.0531871"
                },
                "count": 2,
                "orderPrice": 4000,
                "createdAt": "2023-04-12T22:12:34.0511866",
                "updatedAt": null
            }
        ],
        "totalPrice": 14000,
        "createdAt": "2023-04-12T22:12:34.0461864",
        "updatedAt": null
    }
}
```

![10](images/10.png)

## 1. 프로젝트 세팅

- config
- controller
- core
- dto
- model

![11](images/11.png)

### (1) 의존성

```groovy
dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-aop'
	implementation 'org.springframework.boot:spring-boot-starter-validation'
	implementation group: 'com.auth0', name: 'java-jwt', version: '4.3.0'
	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
	implementation 'org.springframework.boot:spring-boot-starter-web'
	compileOnly 'org.projectlombok:lombok'
	developmentOnly 'org.springframework.boot:spring-boot-devtools'
	runtimeOnly 'com.h2database:h2'
	annotationProcessor 'org.projectlombok:lombok'
	testImplementation 'org.springframework.boot:spring-boot-starter-test'
}
```

### (2) application.yml

```yaml
server:
  servlet:
    encoding:
      charset: utf-8
      force: true
spring:
  datasource:
    url: jdbc:h2:mem:test;MODE=MySQL
    driver-class-name: org.h2.Driver
    username: sa
    password:
  h2:
    console:
      enabled: true
  jpa:
    hibernate:
      ddl-auto: create
    show-sql: true
    properties:
      hibernate:
        format_sql: true
      # in query 자동 작성
      default_batch_fetch_size: 100

  # 404 처리하는 법
  mvc:
    throw-exception-if-no-handler-found: true
  web:
    resources:
      add-mappings: false
  # hibernateLazyInitializer 오류 해결법
  # jackson:
  #  serialization:
  #    fail-on-empty-beans: false

logging:
  level:
    '[shop.mtcoding.metamall]': DEBUG # DEBUG 레벨부터 에러 확인할 수 있게 설정하기, 배포시 INFO
    '[org.hibernate.type]': TRACE # 콘솔 쿼리에 ? 에 주입된 값 보기
```

## 2. Model 세팅

![12](images/12.png)

> User Entity 생성

- model/user/User.java

```java
@NoArgsConstructor
@Setter // DTO 만들면 삭제해야됨
@Getter
@Table(name = "user_tb")
@Entity
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @Column(unique = true, nullable = false, length = 20)
    private String username;
    @JsonIgnore
    @Column(nullable = false, length = 60) // BCrypt로 암호화 하면 60Byte
    private String password;
    @Column(nullable = false, length = 50)
    private String email;
    @Column(nullable = false, length = 10)
    private String role; // USER(고객), SELLER(판매자), ADMIN(관리자)
    @Column(nullable = false, length = 10)
    private Boolean status; // 활성, 비활성
    @Column(nullable = false) // 무조건 들어와야함
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        this.createdAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        this.updatedAt = LocalDateTime.now();
    }

    @Builder
    public User(Long id, String username, String password, String email, String role, Boolean status, LocalDateTime createdAt, LocalDateTime updatedAt) {
        this.id = id;
        this.username = username;
        this.password = password;
        this.email = email;
        this.role = role;
        this.status = status;
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
    }

    // 권한 변경 (관리자)
    public void updateRole(String role){
        if(this.role.equals(role)){
            throw new Exception400("role", "동일한 권한으로 변경할 수 없습니다");
        }
        this.role = role;
    }

    // 회원 탈퇴
    public void delete(){
        this.status = false;
    }
}
```

> Product Entity 생성
>
> 상품 등록을 누가하는지 알아야 하기 때문에 seller 등록

- model/product/Product.java

```java
@NoArgsConstructor
@Setter // DTO 만들면 삭제해야됨
@Getter
@Table(name = "product_tb")
@Entity
public class Product {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @ManyToOne
    private User seller; // 판매자 1명 가정, seller_id
    @Column(nullable = false, length = 50)
    private String name; // 상품 이름
    @Column(nullable = false)
    private Integer price; // 상품 가격
    @Column(nullable = false)
    private Integer qty; // 상품 재고
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        this.createdAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        this.updatedAt = LocalDateTime.now();
    }

    @Builder
    public Product(Long id, User seller, String name, Integer price, Integer qty, LocalDateTime createdAt, LocalDateTime updatedAt) {
        this.id = id;
        this.seller = seller;
        this.name = name;
        this.price = price;
        this.qty = qty;
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
    }

    // 상품 변경 (판매자)
    public void update(String name, Integer price, Integer qty){
        this.name = name;
        this.price = price;
        this.qty = qty;
    }

    // 주문시 재고 변경 (구매자)
    public void updateQty(Integer orderCount){
        if(this.qty < orderCount){
            throw new Exception400("count", "주문수량이 재고 수량을 초과하였습니다");
        }
        this.qty = this.qty - orderCount;
    }

    // 주문 취소 재고 변경 (구매자, 판매자)
    public void rollbackQty(Integer orderCount){
        this.qty = this.qty + orderCount;
    }
}
```

> OrderProduct Entity 생성
>
> 상품 주문시에 여러 상품을 주문할 수 있다. 바나나 5개, 딸기 10개
>
> 이렇게 주문할 물품으로 주문서(OrderSheet)를 만들면 된다. 
>
> 즉 주문서는 여러 주문상품으로 만들어진다.

- model/order/product/OrderProduct.java

```java
@NoArgsConstructor
@Setter // DTO 만들면 삭제해야됨
@Getter
@Table(name = "order_product_tb")
@Entity
public class OrderProduct { // 주문 상품

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @JsonIgnoreProperties({"seller"})
    @ManyToOne // checkpoing -> 무한참조
    private Product product;
    @Column(nullable = false)
    private Integer count; // 상품 주문 개수
    @Column(nullable = false)
    private Integer orderPrice; // 상품 주문 금액
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    @JsonIgnoreProperties({"orderProductList"})
    @ManyToOne
    private OrderSheet orderSheet;

    @PrePersist
    protected void onCreate() {
        this.createdAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        this.updatedAt = LocalDateTime.now();
    }

    @Builder
    public OrderProduct(Long id, Product product, Integer count, Integer orderPrice, LocalDateTime createdAt, LocalDateTime updatedAt, OrderSheet orderSheet) {
        this.id = id;
        this.product = product;
        this.count = count;
        this.orderPrice = orderPrice;
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
        this.orderSheet = orderSheet;
    }

    // 연관관계 편의 메서드
    public void syncOrderSheet(OrderSheet orderSheet){
        this.orderSheet = orderSheet;
    }
}
```

> `JsonIgnoreProperties, JsonIgonre`
>
> JsonIgnoreProperties : 적혀있는 변수의 데이터를 JSON으로 파싱하지 않겠다는 것
> JsonIgonre : 해당 어노테이션이 붙은 뱐수를 JSON으로 파싱하지 않겠다는 것

> OrderSheet Entity 생성
>
> @OneToMany로 orderProductList를 가져야 한다. 그리고 연관관계 편의 메서드를 만들어 둔다.

- model/order/sheet/OrderSheet.java

```java
@NoArgsConstructor
@Setter // DTO 만들면 삭제해야됨
@Getter
@Table(name = "order_sheet_tb")
@Entity
public class OrderSheet { // 주문서

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @ManyToOne
    private User user; // 주문자
    @JsonIgnoreProperties({"orderSheet"}) // orderSheet를 JSON으로 변환 X 의미
    @OneToMany(mappedBy = "orderSheet", cascade = CascadeType.ALL, orphanRemoval = true) // checkpoint -> 무한참조, 양방향 매핑 관리
    private List<OrderProduct> orderProductList = new ArrayList<>(); // 총 주문 상품 리스트
    @Column(nullable = false)
    private Integer totalPrice; // 총 주문 금액 (총 주문 상품 리스트의 orderPrice 합)
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        this.createdAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        this.updatedAt = LocalDateTime.now();
    }

    @Builder
    public OrderSheet(Long id, User user, Integer totalPrice, LocalDateTime createdAt, LocalDateTime updatedAt) {
        this.id = id;
        this.user = user;
        this.totalPrice = totalPrice;
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
    }

    public void addOrderProduct(OrderProduct orderProduct){
        orderProductList.add(orderProduct);
        orderProduct.syncOrderSheet(this);
    }

    public void removeOrderProduct(OrderProduct orderProduct){
        orderProductList.remove(orderProduct);
        orderProduct.syncOrderSheet(null);
    }
}
```

> LoginLog Entity 생성
>
> 로그인 로그를 데이터베이스에 남긴다.

- model/log/login/LoginLog.java

```java
@NoArgsConstructor
@Setter // DTO 만들면 삭제해야됨
@Getter
@Table(name = "login_log_tb")
@Entity
public class LoginLog {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private Long userId;
    private String userAgent;
    private String clientIP;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        this.createdAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        this.updatedAt = LocalDateTime.now();
    }

    @Builder
    public LoginLog(Long id, Long userId, String userAgent, String clientIP, LocalDateTime createdAt) {
        this.id = id;
        this.userId = userId;
        this.userAgent = userAgent;
        this.clientIP = clientIP;
        this.createdAt = createdAt;
    }
}
```

> ErrorLog Entity 생성
>
> 에러 로그를 데이터베이스에 남긴다.

- model/log/error/ErrorLog.java

```java
@NoArgsConstructor
@Setter // DTO 만들면 삭제해야됨
@Getter
@Table(name = "error_log_tb")
@Entity
public class ErrorLog {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @Column(nullable = false, length = 10000000)
    private String msg;
    @Column(nullable = false)
    private Long userId;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        this.createdAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        this.updatedAt = LocalDateTime.now();
    }

    @Builder
    public ErrorLog(Long id, String msg, Long userId, LocalDateTime createdAt, LocalDateTime updatedAt) {
        this.id = id;
        this.msg = msg;
        this.userId = userId;
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
    }
}
```

## 3. Repository 생성

- model/user/UserRepository.java

```java
public interface UserRepository extends JpaRepository<User, Long> {

    @Query("select u from User u where u.username = :username")
    Optional<User> findByUsername(@Param("username") String username);
}
```

- model/product/ProductRepository.java

```java
public interface ProductRepository extends JpaRepository<Product, Long> {}
```

- model/order/product/OrderProductRepository.java

```java
public interface OrderProductRepository extends JpaRepository<OrderProduct, Long> {}
```

- model/order/sheet/OrderSheetRepository.java

```java
public interface OrderSheetRepository extends JpaRepository<OrderSheet, Long> {

    // 내가 주문한 목록보기
    @Query("select os from OrderSheet os where os.user.id = :userId")
    List<OrderSheet> findByUserId(@Param("userId") Long userId);
}
```

- model/log/login/LoginLogRepository.java

```java
public interface LoginLogRepository extends JpaRepository<LoginLog, Long> {}
```

- model/log/error/ErrorLogRepository.java

```java
public interface ErrorLogRepository extends JpaRepository<ErrorLog, Long> {}
```

## 4. 더미데이터 세팅

> CommandLineRunner는 스프링부트가 실행될 때, return 부분에 람다 함수를 실행해서 데이터를 초기화 해준다.

```java
@SpringBootApplication
public class MetamallApplication {

	@Bean
	CommandLineRunner initData(UserRepository userRepository, ProductRepository productRepository, OrderProductRepository orderProductRepository, OrderSheetRepository orderSheetRepository){
		return (args)->{
			User ssar = User.builder().username("ssar").password("1234").email("ssar@nate.com").role("USER").status(true).build();
			User seller = User.builder().username("seller").password("1234").email("seller@nate.com").role("SELLER").status(true).build();
			User admin = User.builder().username("admin").password("1234").email("admin@nate.com").role("ADMIN").status(true).build();
			userRepository.saveAll(Arrays.asList(ssar, seller, admin)); // 벌크 컬렉터
		};
	}

	public static void main(String[] args) {
		SpringApplication.run(MetamallApplication.class, args);
	}
}
```

## 5. Core 세팅

### (1) 유틸리티

> LocalDateTime을 예쁘게 포맷해서 응답하는 메서드 만들기

- core/util/MyDateUtil.java

```java
public class MyDateUtil {
    public static String toStringFormat(LocalDateTime localDateTime) {
        return localDateTime.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
    }
}
```

> Filter에서 터진 예외는 ExceptionAdvice(예외 핸들러)를 사용하여 처리할 수 없기 때문에, 만들어두자.

- core/util/MyFilterResponseUtils.java

```java
// Filter는 예외 핸들러로 처리하지 못한다.
public class MyFilterResponseUtils {

    public static void badRequest(HttpServletResponse resp, Exception400 e) throws IOException {
        resp.setStatus(400);
        resp.setContentType("application/json; charset=utf-8");
        ValidDTO validDTO = new ValidDTO(e.getKey(), e.getValue());
        ResponseDTO<?> responseDto = new ResponseDTO<>().fail(HttpStatus.BAD_REQUEST, "badRequest", validDTO);
        ObjectMapper om = new ObjectMapper();
        String responseBody = om.writeValueAsString(responseDto);
        resp.getWriter().println(responseBody);
    }

    public static void unAuthorized(HttpServletResponse resp, Exception e) throws IOException {
        resp.setStatus(401);
        resp.setContentType("application/json; charset=utf-8");
        ResponseDTO<?> responseDto = new ResponseDTO<>().fail(HttpStatus.UNAUTHORIZED, "unAuthorized", e.getMessage());
        ObjectMapper om = new ObjectMapper();
        String responseBody = om.writeValueAsString(responseDto);
        resp.getWriter().println(responseBody);
    }

    public static void forbidden(HttpServletResponse resp, Exception e) throws IOException {
        resp.setStatus(403);
        resp.setContentType("application/json; charset=utf-8");
        ResponseDTO<?> responseDto = new ResponseDTO<>().fail(HttpStatus.FORBIDDEN, "forbidden", e.getMessage());
        ObjectMapper om = new ObjectMapper();
        String responseBody = om.writeValueAsString(responseDto);
        resp.getWriter().println(responseBody);
    }
}
```

### (2) 예외 클래스 만들기

- core/exception/Exception400.java

```java
// 유효성 검사 실패, 잘못된 파라메터 요청
@Getter
public class Exception400 extends RuntimeException {

    private String key;
    private String value;

    public Exception400(String key, String value) {
        super(value);
        this.key = key;
        this.value = value;
    }

    public ResponseDTO<?> body(){
        ResponseDTO<ValidDTO> responseDto = new ResponseDTO<>();
        ValidDTO validDTO = new ValidDTO(key, value);
        responseDto.fail(HttpStatus.BAD_REQUEST, "badRequest", validDTO);
        return responseDto;
    }

    public HttpStatus status(){
        return HttpStatus.BAD_REQUEST;
    }
}
```

- core/exception/Exception401.java

```java
// 인증 안됨
@Getter
public class Exception401 extends RuntimeException {

    public Exception401(String message) {
        super(message);
    }

    public ResponseDTO<?> body(){
        ResponseDTO<String> responseDto = new ResponseDTO<>();
        responseDto.fail(HttpStatus.UNAUTHORIZED, "unAuthorized", getMessage());
        return responseDto;
    }

    public HttpStatus status(){
        return HttpStatus.UNAUTHORIZED;
    }
}
```

- core/exception/Exception403.java

```java
// 권한 없음
@Getter
public class Exception403 extends RuntimeException {

    public Exception403(String message) {
        super(message);
    }

    public ResponseDTO<?> body(){
        ResponseDTO<String> responseDto = new ResponseDTO<>();
        responseDto.fail(HttpStatus.FORBIDDEN, "forbidden", getMessage());
        return responseDto;
    }

    public HttpStatus status(){
        return HttpStatus.FORBIDDEN;
    }
}
```

### (3) 깃발 만들기 (어노테이션)

> 에러가 발생하면 자동으로 DB에 기록하는 깃발

- core/annotation/MyErrorLogRecord.java

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyErrorLogRecord {
}
```

> @PathVariable로 전달되는 id값과 session의 id값을 비교하여 권한 체크해주는 깃발

- core/annotation/MySameUserIdCheck.java

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface MySameUserIdCheck {
}
```

> SessionUser 객체앞에 @MySessionStore를 붙여주면 자동으로 값을 주입해주는 깃발

- core/annotation/MySessionStore.java

```java
@Target(ElementType.PARAMETER)
@Retention(RetentionPolicy.RUNTIME)
public @interface MySessionStore {
}
```

### (4) 깃발에 따라 행동할 Advice 공통모듈 만들기

> 에러 로그를 기록하는 Advice

- core/advice/MyErrorLogAdvice.java

```java
@RequiredArgsConstructor
@Aspect
@Component
public class MyErrorLogAdvice {

    private final HttpSession session;
    private final ErrorLogRepository errorLogRepository;

    @Pointcut("@annotation(shop.mtcoding.metamall.core.annotation.MyErrorLogRecord)")
    public void myErrorLog(){}

    @Before("myErrorLog()")
    public void errorLogAdvice(JoinPoint jp) throws HttpMessageNotReadableException {
        Object[] args = jp.getArgs();

        for (Object arg : args) {
            if(arg instanceof Exception){
                Exception e = (Exception) arg;
                SessionUser sessionUser = (SessionUser) session.getAttribute("sessionUser");
                if(sessionUser != null){
                    ErrorLog errorLog =ErrorLog.builder().userId(sessionUser.getId()).msg(e.getMessage()).build();
                    errorLogRepository.save(errorLog);
                }
            }
        }
    }
}
```

> 메서드의 파라메터에 접근해서 값을 가져와서 동일한 유저 권한인지 체크하는 Advice

- core/advice/MySameUserIdAdvice.java

```java
@RequiredArgsConstructor
@Aspect
@Component
public class MySameUserIdAdvice {

    private final HttpSession session;

    // 깃발에 별칭주기
    @Pointcut("@annotation(shop.mtcoding.metamall.core.annotation.MySameUserIdCheck)")
    public void mySameUserId(){}

    @Before("mySameUserId()")
    public void sameUserIdAdvice(JoinPoint jp) {
        Object[] args = jp.getArgs();
        MethodSignature signature = (MethodSignature) jp.getSignature();
        Method method = signature.getMethod();
        Parameter[] parameters = method.getParameters();

        IntStream.range(0, parameters.length).forEach(
                (i) -> {
                    if(parameters[i].getName().equals("id") && parameters[i].getType() == Long.class){
                        SessionUser sessionUser = (SessionUser) session.getAttribute("sessionUser");
                        Long id = (Long) args[i];
                        if(sessionUser.getId() != id){
                            throw new Exception403("해당 id에 접근할 권한이 없습니다");
                        }
                    }
                }
        );
    }
}
```

> 에러에 따라, 어떻게 예외를 처리할 것인지를 정의한 Advice
>
> 404 처리 방법은 yml 설정 참고
>
> 내가 직접 제어하지 못한 예외는 Exception.class 로 잡아서 에러 로그로 기록해두면, 추후에 에러 로그 확인해서 해당하는 예외를 잡아서 처리하는 Handler를 등록할 수 있다.

- core/advice/MyExceptionAdvice.java

```java
@Slf4j
@RestControllerAdvice
public class MyExceptionAdvice {

    @MyErrorLogRecord
    @ExceptionHandler(Exception400.class)
    public ResponseEntity<?> badRequest(Exception400 e){
        return new ResponseEntity<>(e.body(), e.status());
    }

    @MyErrorLogRecord
    @ExceptionHandler(Exception401.class)
    public ResponseEntity<?> unAuthorized(Exception401 e){
        return new ResponseEntity<>(e.body(), e.status());
    }

    @MyErrorLogRecord
    @ExceptionHandler(Exception403.class)
    public ResponseEntity<?> forbidden(Exception403 e){
        return new ResponseEntity<>(e.body(), e.status());
    }

    @MyErrorLogRecord
    @ExceptionHandler(NoHandlerFoundException.class)
    public ResponseEntity<?> notFound(NoHandlerFoundException e){
        ResponseDTO<String> responseDto = new ResponseDTO<>();
        responseDto.fail(HttpStatus.NOT_FOUND, "notFound", e.getMessage());
        return new ResponseEntity<>(responseDto, HttpStatus.NOT_FOUND);
    }

    @MyErrorLogRecord
    @ExceptionHandler(Exception.class) // 나머지 모든 예외는 이 친구에게 다 걸러진다.
    public ResponseEntity<?> unknownServerError(Exception e){
        ResponseDTO<String> responseDto = new ResponseDTO<>();
        responseDto.fail(HttpStatus.INTERNAL_SERVER_ERROR, "unknownServerError", e.getMessage());
        return new ResponseEntity<>(responseDto, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
```

> `log`
>
> application.yml으로 관리
> - 순서 : trace -> debug -> info -> warn -> error
> - debug로 잡을 경우(개발시) : debug -> info -> warn -> error
> - info로 잡을 경우 : info -> warn -> error
> - warn로 잡을 경우 : warn -> error
> - error로 잡을 경우 : error

> 유효성을 검사하는 Advice
>
> 해당 Advice에서 모든 에러가 아닌, 전체 에러중 가장 첫번째 것만 응답해주면 된다. (그게 더 심플하다)

- core/advice/MyValidAdvice.java

```java
@Aspect
@Component
public class MyValidAdvice {

    @Pointcut("@annotation(org.springframework.web.bind.annotation.PostMapping)")
    public void postMapping() {
    }

    @Pointcut("@annotation(org.springframework.web.bind.annotation.PutMapping)")
    public void putMapping() {
    }

    @Before("postMapping() || putMapping()")
    public void validationAdvice(JoinPoint jp) {
        Object[] args = jp.getArgs();
        for (Object arg : args) {
            if (arg instanceof Errors) {
                Errors errors = (Errors) arg;

                if (errors.hasErrors()) {
                    throw new Exception400(
                            errors.getFieldErrors().get(0).getField(),
                            errors.getFieldErrors().get(0).getDefaultMessage()
                    );
                }
            }
        }
    }
}
```

### (5) JWT 설정

> Jwt Login은 Controller에서 처리할 예정이다. (필터에서 해도 되지만, DB에 로그인 기록을 남길 것이라서, 컨트롤러에서 처리함)

#### JwtProvider

> SECRET은 환경변수로 등록하고 가져와서 쓰는 것을 추천한다.

- core/jwt/JwtProvider.java

```java
public class JwtProvider {

    private static final String SUBJECT = "jwtstudy";
    private static final int EXP = 1000 * 60 * 60;
    public static final String TOKEN_PREFIX = "Bearer "; // 스페이스 필요함
    public static final String HEADER = "Authorization";
    private static final String SECRET = "메타코딩";

    public static String create(User user) {
        String jwt = JWT.create()
                .withSubject(SUBJECT)
                .withExpiresAt(new Date(System.currentTimeMillis() + EXP))
                .withClaim("id", user.getId())
                .withClaim("role", user.getRole())
                .sign(Algorithm.HMAC512(SECRET));
        System.out.println("디버그 : 토큰 생성됨");
        return TOKEN_PREFIX + jwt;
    }

    public static DecodedJWT verify(String jwt) throws SignatureVerificationException, TokenExpiredException {
        DecodedJWT decodedJWT = JWT.require(Algorithm.HMAC512(SECRET))
                .build().verify(jwt);
        System.out.println("디버그 : 토큰 검증됨");
        return decodedJWT;
    }
}
```

#### MyJwtVerifyFilter

> JWT 토큰이 존재하면, 검증 후에 해당 자원에 접근할 수 있게 해주면 된다.
>
> 이때 Filter에서 DS를 거쳐서 Controller로 진입하게 되는데, Controller에서 사용자 정보를 얻기 위해 JWT토큰을 다시 파싱하는 것보다는 Session에 넣어두고, 필요할 때 Session에서 가져와서 쓰는 것이 좋다.
>
> 
>
> 아래 코드가 작동하려면 MyFilterRegisterConfig에 등록해줘야 한다.

- core/filter/MyJwtVerifyFilter.java

```java
public class MyJwtVerifyFilter implements Filter {

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        HttpServletRequest req = (HttpServletRequest) request;
        HttpServletResponse resp = (HttpServletResponse) response;
        String prefixJwt = req.getHeader(JwtProvider.HEADER);

        if(prefixJwt == null){
            MyFilterResponseUtils.badRequest(resp, new Exception400("authorization", "토큰이 전달되지 않았습니다"));
            return;
        }

        String jwt = prefixJwt.replace(JwtProvider.TOKEN_PREFIX, "");
        try {
            DecodedJWT decodedJWT = JwtProvider.verify(jwt);
            Long id = decodedJWT.getClaim("id").asLong();
            String role = decodedJWT.getClaim("role").asString();

            // 세션을 사용하는 이유는 role(권한) 처리를 하기 위해서이다.
            HttpSession session =  req.getSession();
            SessionUser sessionUser = SessionUser.builder().id(id).role(role).build();
            session.setAttribute("sessionUser", sessionUser);
            System.out.println("세션 생성됨");
            chain.doFilter(req, resp);
        }catch (SignatureVerificationException sve){
            MyFilterResponseUtils.unAuthorized(resp, sve);
        }catch (TokenExpiredException tee){
            MyFilterResponseUtils.unAuthorized(resp, tee);
        }
    }
}
```

### (6) 세션 정보 자동 주입

- core/session/SessionUser.java

```java
@Getter
public class SessionUser {

    private Long id;
    private String role;

    @Builder
    public SessionUser(Long id, String role) {
        this.id = id;
        this.role = role;
    }
}
```

> 아래 코드가 작동하려면 MyWebMvcConfig에 등록해줘야 한다.

- core/resolver/MySessionArgumentResolver.java

```java
@RequiredArgsConstructor
@Configuration
public class MySessionArgumentResolver implements HandlerMethodArgumentResolver {

    private final HttpSession session;

    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        boolean check1 = parameter.getParameterAnnotation(MySessionStore.class) != null;
        boolean check2 = SessionUser.class.equals(parameter.getParameterType());
        return check1 && check2;
    }

    @Override
    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {
        return session.getAttribute("sessionUser");
    }
}
```

### (7) 권한처리를 위한 인터셉터 등록

> 추후 시큐리티 라이브러리를 배우게 되면, 권한처리를 인터셉터로 하지 않아도 된다.

- core/interceptor/MyAdminInterceptor.java

```java
@Configuration
public class MyAdminInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        HttpSession session = request.getSession();
        SessionUser sessionUser = (SessionUser) session.getAttribute("sessionUser");

        if(!sessionUser.getRole().equals("ADMIN")){
            throw new Exception403("권한이 없습니다");
        }
        return true;
    }
}
```

- core/interceptor/MySellerInterceptor.java

```java
@Configuration
public class MySellerInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        HttpSession session = request.getSession();
        SessionUser sessionUser = (SessionUser) session.getAttribute("sessionUser");

        if(sessionUser.getRole().equals("SELLER") || sessionUser.getRole().equals("ADMIN")){
            return true;
        }else{
            throw new Exception403("권한이 없습니다");
        }
    }
}
```

## 6. Config 설정

> JWT Verify 검증 필터는 아래 5가지 주소 유형에서 작동하게 될 예정이다.

- config/MyFilterRegisterConfig.java

```java
@Configuration
public class MyFilterRegisterConfig {

    @Bean
    public FilterRegistrationBean<?> jwtVerifyFilterAdd() {
        FilterRegistrationBean<MyJwtVerifyFilter> registration = new FilterRegistrationBean<>();
        registration.setFilter(new MyJwtVerifyFilter());
        registration.addUrlPatterns("/users/*");
        registration.addUrlPatterns("/products/*");
        registration.addUrlPatterns("/orders/*");
        registration.addUrlPatterns("/admin/*");
        registration.addUrlPatterns("/seller/*");
        registration.setOrder(1);
        return registration;
    }
}
```

> WebMvcConfigurer 구현체에는 여러가지를 등록할 수 있다. 대표적인 것은 아래와 같다.
>
> CORS 설정
>
> MessageConverter 설정
>
> ViewResolver 설정
>
> Interceptor 설정
>
> ArgumentResolver 설정

- config/MyWebMvcConfig.java
```java
@RequiredArgsConstructor
@Configuration
public class MyWebMvcConfig implements WebMvcConfigurer {

    private final MyAdminInterceptor adminInterceptor;
    private final MySellerInterceptor sellerInterceptor;
    private final MySessionArgumentResolver mySessionArgumentResolver;

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedHeaders("*")
                .allowedMethods("*") // GET, POST, PUT, DELETE (Javascript 요청 허용)
                .allowedOriginPatterns("*") // 모든 IP 주소 허용 (프론트 앤드 IP만 허용하게 변경해야함. * 안됨)
                .allowCredentials(true)
                .exposedHeaders("Authorization"); // 옛날에는 디폴트로 브라우저에 노출되어 있었는데 지금은 아님
    }

    // AOP는 매개변수 값 확인해서 권한 비교해야할 때 사용
    // Interceptor는 세션 권한으로 체크할 때 사용
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(adminInterceptor)
                .addPathPatterns("/admin/**");

        registry.addInterceptor(sellerInterceptor)
                .addPathPatterns("/seller/**");
    }

    @Override
    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> resolvers) {
        resolvers.add(mySessionArgumentResolver);
    }
}
```

## 7. DTO 생성

![13](images/13.png)

### (1) 공통 응답 DTO와 공통 유효성 DTO 생성

> 정상 : new ResponseDTO<>(); (DELETE)
>
> 정상인데 응답해줄 데이터가 있을 때 (POST, PUT, GET) : new ResponseDTO<>().data("응답할 데이터");
>
> 비정상(에러) : new ResponseDTO<>().fail(401, "권한없음", "상세 에러메시지");

- dto/ResponseDTO.java

```java
@Getter
public class ResponseDTO<T> {

    private Integer status; // 에러시에 의미 있음.
    private String msg; // 에러시에 의미 있음. ex) badRequest
    private T data; // 에러시에는 구체적인 에러 내용 ex) username이 입력되지 않았습니다

    // delete 요청 - 성공
    public ResponseDTO(){
        this.status = HttpStatus.OK.value();
        this.msg = "성공";
        this.data = null;
    }

    // get, put, post - 성공
    public ResponseDTO<?> data(T data){
        this.data = data; // 응답할 데이터 바디
        return this;
    }

    // 4가지 요청에 대한 실패
    public ResponseDTO<?> fail(HttpStatus httpStatus, String msg, T data){
        this.status = httpStatus.value();
        this.msg = msg; // 에러 제목
        this.data = data; // 에러 내용
        return this;
    }
}
```

- dto/ValidDTO.java

```java
@AllArgsConstructor
@Getter
@Setter
public class ValidDTO {

    private String key;
    private String value;
}
```

### (2) 나머지 DTO

> DTO로 유효성 검사를 진행한다. INSERT할 DTO에만 toEntity()가 필요하다.

- dto/user/UserRequest.java

```java
public class UserRequest {

    @Getter @Setter
    public static class JoinDTO {

        // Size는 String에만 쓸 수 있다.
        @NotEmpty
        @Size(min = 3, max = 20)
        private String username;

        @NotEmpty
        @Size(min = 4, max = 20) // DB에는 60자, 실제 받을 때는 20자 이하
        private String password;

        // Pattern은 String에만 쓸 수 있다.
        @NotEmpty
        @Pattern(regexp = "^[\\w._%+-]+@[\\w.-]+\\.[a-zA-Z]{2,6}$", message = "이메일 형식이 아닙니다")
        private String email;

        @NotEmpty
        @Pattern(regexp = "USER|SELLER|ADMIN")
        private String role;
        
        // INSERT DTO만 무조건 toEntity()를 만든다.
        public User toEntity(){
            return User.builder()
                    .username(username)
                    .password(password)
                    .email(email)
                    .role(role)
                    .status(true)
                    .build();
        }
    }

    @Getter @Setter
    public static class LoginDTO {
        @NotEmpty
        private String username;
        @NotEmpty
        private String password;
    }

    @Getter @Setter
    public static class RoleUpdateDTO {
        @NotEmpty
        private String role;
    }
}
```

> 숫자 범위는 Digits으로 검증하고 NotNull을 사용한다.
>
> 문자 범위는 Size로 검증하고 NotEmpty를 사용한다.

- dto/product/ProductRequest.java

```java
public class ProductRequest {

    @Getter @Setter
    public static class SaveDTO {
        @NotEmpty
        private String name;

        // 숫자는 NotNull로 검증한다
        @Digits(fraction = 0, integer = 9)
        @NotNull
        private Integer price;

        @Digits(fraction = 0, integer = 9)
        @NotNull
        private Integer qty;

        public Product toEntity(User seller){
            return Product.builder()
                    .name(name)
                    .price(price)
                    .qty(qty)
                    .seller(seller)
                    .build();
        }
    }

    @Getter @Setter
    public static class UpdateDTO {
        @NotEmpty
        private String name;

        @Digits(fraction = 0, integer = 9)
        @NotNull
        private Integer price;

        @Digits(fraction = 0, integer = 9)
        @NotNull
        private Integer qty;
    }
}
```

> 주문하기 DTO인데, 해당 DTO는 지금 만들지 말고, 추후에 주문하기 로직을 만들어야 할 때 만들자!! - 지금하면 이해하기 힘들다.

- dto/order/OrderRequest.java

```java
public class OrderRequest {

    @Getter
    @Setter
    public static class SaveDTO {

        private List<OrderProductDTO> orderProducts;

        @Getter
        @Setter
        public static class OrderProductDTO {
            private Long productId;
            private Integer count;
        }

        // 1. request 요청으로 들어온 product id만 리스트로 뽑아내기
        public List<Long> getIds() {
            return orderProducts.stream().map((orderProduct) -> orderProduct.getProductId()).collect(Collectors.toList());
        }

        // 3. 주문 상품 리스트 만들어 내기
        public List<OrderProduct> toEntity(List<Product> products) { // 2. getIds() 로 뽑아낸 번호로 상품 리스트 찾아내서 주입하기

            // 4. request 요청으로 들어온 DTO에 count 값이 필요해서 stream() 두번 돌렸음. 주문 상품 금액을 만들어 내야 해서!!
            return orderProducts.stream()
                    // 5. map은 다시 collect로 수집해야 하기 때문에, flatMap으로 평탄화 작업함.
                    .flatMap((orderProduct) -> {
                                Long productId = orderProduct.productId;
                                Integer count = orderProduct.getCount();
                                // 6. OrderProduct 객체 만들어내기 (주문한 상품만큼)
                                return products.stream()
                                        .filter((product) -> product.getId().equals(productId))
                                        .map((product) -> OrderProduct.builder()
                                                .product(product)
                                                .count(count)
                                                .orderPrice(product.getPrice() * count)
                                                .build());
                            }
                    ).collect(Collectors.toList()); // 7. 최종 수집
        }
    }
}
```

## 8. Controller 설정

- controller/UserController/java

```java
/**
 * 회원가입, 로그인, 유저상세보기
 */
@RequiredArgsConstructor
@RestController
public class UserController {

    private final UserRepository userRepository;
    private final LoginLogRepository loginLogRepository;

    @PostMapping("/join")
    public ResponseEntity<?> join(@RequestBody @Valid UserRequest.JoinDTO joinDTO, Errors errors) {
        User userPS = userRepository.save(joinDTO.toEntity());
        // REST api는 INSERT, UPDATE, SELECT 된 모든 데이터를 응답해줘야 한다.
        ResponseDTO<?> responseDto = new ResponseDTO<>().data(userPS);
        return ResponseEntity.ok().body(responseDto);
    }

    @PostMapping("/login")
    public ResponseEntity<?> login(@RequestBody @Valid UserRequest.LoginDTO loginDTO, Errors errors, HttpServletRequest request) {
        User userPS = userRepository.findByUsername(loginDTO.getUsername())
                .orElseThrow(
                        () -> new Exception400("username", "유저네임을 찾을 수 없습니다")
                );

        // 1. 패스워드 검증하기
        if (!userPS.getPassword().equals(loginDTO.getPassword())) {
            throw new Exception400("password", "패스워드가 잘못입력되었습니다");
        }

        // 2. JWT 생성하기
        String jwt = JwtProvider.create(userPS);

        // 3. 최종 로그인 날짜 기록 (더티체킹 - update 쿼리 발생)
        userPS.setUpdatedAt(LocalDateTime.now());

        // 4. 로그 테이블 기록
        LoginLog loginLog = LoginLog.builder()
                .userId(userPS.getId())
                .userAgent(request.getHeader("User-Agent"))
                .clientIP(request.getRemoteAddr())
                .build();
        loginLogRepository.save(loginLog);

        // 5. 응답 DTO 생성
        ResponseDTO<?> responseDto = new ResponseDTO<>().data(userPS);
        return ResponseEntity.ok().header(JwtProvider.HEADER, jwt).body(responseDto);
    }

    @MySameUserIdCheck
    @GetMapping("/users/{id}")
    public ResponseEntity<?> findById(@PathVariable Long id){
        User userPS =userRepository.findById(id).orElseThrow(
                ()-> new Exception400("id", "유저를 찾을 수 없습니다")
        );
        ResponseDTO<?> responseDto = new ResponseDTO<>().data(userPS);
        return ResponseEntity.ok().body(responseDto);
    }
}
```

- controller/ProductController.java

```java
/**
 * 상품등록, 상품목록보기, 상품상세보기, 상품수정하기, 상품삭제하기
 */
@RequiredArgsConstructor
@RestController
public class ProductController {

    private final ProductRepository productRepository;
    private final UserRepository userRepository;
    private final HttpSession session;

    // 인터셉터가 판매작인지 권한체크를 함
    @PostMapping("/seller/products")
    public ResponseEntity<?> save(@RequestBody @Valid ProductRequest.SaveDTO saveDTO, Errors errors, @MySessionStore SessionUser sessionUser){
        // 1. 판매자 찾기
        User sellerPS = userRepository.findById(sessionUser.getId())
                .orElseThrow(
                        ()-> new Exception400("id", "판매자를 찾을 수 없습니다")
                );

        // 2. 상품 등록하기
        Product product = saveDTO.toEntity(sellerPS); // product 비영속, sellerPS 영속
        Product productPS = productRepository.save(product); // productPS 영속
        ResponseDTO<?> responseDto = new ResponseDTO<>().data(productPS);
        return ResponseEntity.ok().body(responseDto);
    }

    // http://localhost:8080/products?page=1
    @GetMapping("/products")
    public ResponseEntity<?> findAll(@PageableDefault(size = 10, page = 0, direction = Sort.Direction.DESC) Pageable pageable){
        // 1. 상품 찾기
        Page<Product> productPagePS = productRepository.findAll(pageable);
        
        // 2. 응답하기
        ResponseDTO<?> responseDto = new ResponseDTO<>().data(productPagePS);
        return ResponseEntity.ok().body(responseDto);
    }

    @GetMapping("/products/{id}")
    public ResponseEntity<?> findById(@PathVariable Long id){
        // 1. 상품 찾기
        Product productPS = productRepository.findById(id).orElseThrow(()-> new Exception400("id", "해당 상품을 찾을 수 없습니다"));
        
        // 2. 응답하기
        ResponseDTO<?> responseDto = new ResponseDTO<>().data(productPS);
        return ResponseEntity.ok().body(responseDto);
    }

    @Transactional // 더티체킹 하고 싶다면 붙이기!!
    @PutMapping("/seller/products/{id}")
    public ResponseEntity<?> update(@PathVariable Long id, @RequestBody @Valid ProductRequest.UpdateDTO updateDTO, Errors errors){
        // 1. 상품 찾기
        Product productPS = productRepository.findById(id).orElseThrow(()-> new Exception400("id", "해당 상품을 찾을 수 없습니다"));
        
        // 2. Update 더티체킹
        productPS.update(updateDTO.getName(), updateDTO.getPrice(), updateDTO.getQty());

        // 3. 응답하기
        ResponseDTO<?> responseDto = new ResponseDTO<>().data(productPS);
        return ResponseEntity.ok().body(responseDto);
    }

    @DeleteMapping("/seller/products/{id}")
    public ResponseEntity<?> deleteById(@PathVariable Long id){
        // 잠깐 DELETE 하는 동안 DB에 LOCK이 걸리기 때문에, 다른 쓰레드는 이 시간동안 INSERT, UDPATE, DELETE 불가 
        Product productPS = productRepository.findById(id).orElseThrow(()-> new Exception400("id", "해당 상품을 찾을 수 없습니다"));
        productRepository.delete(productPS);
        ResponseDTO<?> responseDto = new ResponseDTO<>();
        return ResponseEntity.ok().body(responseDto);
    } // 종료시에 트랜젝션 종료 - 변경감지 - flush()
}
```

> `hibernateLazyInitialize, findById(), LAZY 전략일 경우`
>
> ![14](images/14.png)
>
> ![15](images/15.png)
>
> 타이밍 문제 때문에 생기는 에러입니다. 왜냐하면 Product는 영속화가 되었기 때문에 PC를 통해 Controller까지 오고 이제 데이터를 보내는 시점에 MessageConverter가 발동하면서 전부 Getter를 때리게 됩니다. 이떄 sellter는 PC에 존재하지 않기 때문에 null이 나오게 되고, null 상태에서 Lazy loading이 되니까 에러가 발생하는 것입니다.
>
> 해결방법
> 1. 미리 Lazy loading
> 2. join fetch
> 3. EAGER 전략
> 4. fail-on-empty-beans : false

- controller/OrderController.java

```java
/**
 * 주문하기(고객), 주문목록보기(고객), 주문목록보기(판매자), 주문취소하기(고객), 주문취소하기(판매자)
 */
@RequiredArgsConstructor
@RestController
public class OrderController {

    private final OrderProductRepository orderProductRepository;
    private final OrderSheetRepository orderSheetRepository;
    private final ProductRepository productRepository;
    private final UserRepository userRepository;

    @Transactional
    @PostMapping("/orders")
    public ResponseEntity<?> save(@RequestBody @Valid OrderRequest.SaveDTO saveDTO, Errors errors, @MySessionStore SessionUser sessionUser) {
        // 1. 세션값으로 유저 찾기
        User userPS = userRepository.findById(sessionUser.getId())
                .orElseThrow(
                        () -> new Exception400("id", "해당 유저를 찾을 수 없습니다")
                );

        // 2. 상품 찾기 (여러개)
        List<Product> productListPS =
                productRepository.findAllById(saveDTO.getIds());

        // 3. 주문 상품
        List<OrderProduct> orderProductListPS = saveDTO.toEntity(productListPS);

        // 4. 주문서 만들기
        Integer totalPrice = orderProductListPS.stream().mapToInt((orderProduct)-> orderProduct.getOrderPrice()).sum();
        OrderSheet orderSheet = OrderSheet.builder()
                .user(userPS)
                .totalPrice(totalPrice)
                .build();
        OrderSheet orderSheetPS = orderSheetRepository.save(orderSheet);

        // 5. 주문서에 상품추가하고 재고감소하기
        orderProductListPS.stream().forEach(
                (orderProductPS -> {
                    orderSheetPS.addOrderProduct(orderProductPS);
                    orderProductPS.getProduct().updateQty(orderProductPS.getCount());
                })
        );

        // 6. 응답하기
        ResponseDTO<?> responseDto = new ResponseDTO<>().data(orderSheetPS);
        return ResponseEntity.ok().body(responseDto);
    }

    // 유저 주문서 조회
    @GetMapping("/orders")
    public ResponseEntity<?> findByUserId(@MySessionStore SessionUser sessionUser){
        List<OrderSheet> orderSheetListPS = orderSheetRepository.findByUserId(sessionUser.getId());
        ResponseDTO<?> responseDto = new ResponseDTO<>().data(orderSheetListPS);
        return ResponseEntity.ok().body(responseDto);
    }

    // 그림 설명 필요!!
    // 배달의 민족은 하나의 판매자에게서만 주문을 할 수 있다. (다른 판매자의 상품이 담기면, 하나만 담을 수 있게 로직이 변한다)
    // 쇼핑몰은 여러 판매자에게서 주문을 할 수 있다.

    // 판매자 주문서 조회
    @GetMapping("/seller/orders")
    public ResponseEntity<?> findBySellerId(){
        // 판매자는 한명이기 때문에 orderProductRepository.findAll() 해도 된다.
        List<OrderSheet> orderSheetListPS = orderSheetRepository.findAll();
        ResponseDTO<?> responseDto = new ResponseDTO<>().data(orderSheetListPS);
        return ResponseEntity.ok().body(responseDto);
    }

    // 유저 주문 취소
    @DeleteMapping("/orders/{id}")
    public ResponseEntity<?> delete(@PathVariable Long id, @MySessionStore SessionUser sessionUser){
        // 1. 주문서 찾기
        OrderSheet orderSheetPS = orderSheetRepository.findById(id).orElseThrow(
                ()-> new Exception400("id", "해당 주문을 찾을 수 없습니다")
        );

        // 2. 해당 주문서의 주인 여부 확인
        if(!orderSheetPS.getUser().getId().equals(sessionUser.getId())){
            throw new Exception403("권한이 없습니다");
        }

        // 3. 재고 변경하기
        orderSheetPS.getOrderProductList().stream().forEach(orderProduct -> {
            orderProduct.getProduct().rollbackQty(orderProduct.getCount());
        });

        // 4. 주문서 삭제하기 (casecade 옵션)
        orderSheetRepository.delete(orderSheetPS);

        // 5. 응답하기
        ResponseDTO<?> responseDto = new ResponseDTO<>();
        return ResponseEntity.ok().body(responseDto);
    }

    // 판매자 주문 취소
    @DeleteMapping("/seller/orders/{id}")
    public ResponseEntity<?> deleteSeller(@PathVariable Long id){
        // 1. 주문서 찾기
        OrderSheet orderSheetPS = orderSheetRepository.findById(id).orElseThrow(
                ()-> new Exception400("id", "해당 주문을 찾을 수 없습니다")
        );

        // 2. 재고 변경하기
        orderSheetPS.getOrderProductList().stream().forEach(orderProduct -> {
            orderProduct.getProduct().rollbackQty(orderProduct.getCount());
        });

        // 3. 주문서 삭제하기 (casecade 옵션)
        orderSheetRepository.delete(orderSheetPS);

        // 4. 응답하기
        ResponseDTO<?> responseDto = new ResponseDTO<>();
        return ResponseEntity.ok().body(responseDto);
    }
}
```

> `stream 특강`
>
> - stream
> - map
> - filter
> - collect
> 
> ![16](images/16.png)
>
> stream은 물줄기라는 의미입니다. 예를 들어, 물줄기에 7마리의 고기가 있고, 거르는 방법에는 map, filter 2가지 방법으로 거를 수 있습니다. 
>
> map로 사용해서 거르면 전체 물고기를 받아옵니다. 이때 받아오는 과정에서 동일한 가공을 거쳐 stream으로 받습니다.
>
> filter로 사용해서 거르면 특정한 물고기들만 골라내서 가져와 stream으로 받습니다.
>
> 받아온 이후에는 수집을 해야합니다. 즉 아직 stream이라는 물줄기에 있으니까 물줄기가 아닌 다른 곳으로 옮기고 원하는 것들만 고르는 것입니다. 따라서 collect를 이용해서 수집을 해줍니다. collect를 사용하면 다른 타입으로의 변경이 가능합니다.

- controller/AdminController.java

```java
/**
 * 권한 변경
 */
@RequiredArgsConstructor
@RestController
public class AdminController {

    private final UserRepository userRepository;

    @Transactional // 트랜잭션이 시작되지 않으면 강제로 em.flush() 를 할 수 없고, 더티체킹도 할 수 없다. (원래는 서비스에서)
    @PutMapping("/admin/user/{id}/role")
    public ResponseEntity<?> updateRole(@PathVariable Long id, @RequestBody @Valid UserRequest.RoleUpdateDTO roleUpdateDTO, Errors errors) {
        User userPS = userRepository.findById(id)
                .orElseThrow(()-> new Exception400("id", "해당 유저를 찾을 수 없습니다"));
        userPS.updateRole(roleUpdateDTO.getRole());

        ResponseDTO<?> responseDto = new ResponseDTO<>();
        return ResponseEntity.ok().body(responseDto);
    }
}
```

## 9. 정규표현식

https://github.com/codingspecialist/junit-bank-class/blob/main/class-note/regex/regex.pdf

- test/java/shop/mtcoding/metamall/regex/RegexTest.java

```java
public class RegexTest {

    @Test
    public void 한글만된다_test() throws Exception {
        String value = "한글";
        boolean result = Pattern.matches("^[가-힣]+$", value);
        System.out.println("테스트 : " + result);
    }

    @Test
    public void 한글은안된다_test() throws Exception {
        String value = "abc";
        boolean result = Pattern.matches("^[^ㄱ-ㅎ가-힣]*$", value);
        System.out.println("테스트 : " + result);
    }

    @Test
    public void 영어만된다_test() throws Exception {
        String value = "ssar";
        boolean result = Pattern.matches("^[a-zA-Z]+$", value);
        System.out.println("테스트 : " + result);
    }

    @Test
    public void 영어는안된다_test() throws Exception {
        String value = "가22";
        boolean result = Pattern.matches("^[^a-zA-Z]*$", value);
        System.out.println("테스트 : " + result);
    }

    @Test
    public void 영어와숫자만된다_test() throws Exception {
        String value = "ab12";
        boolean result = Pattern.matches("^[a-zA-Z0-9]+$", value);
        System.out.println("테스트 : " + result);
    }

    @Test
    public void 영어만되고_길이는최소2최대4이다_test() throws Exception {
        String value = "ssar";
        boolean result = Pattern.matches("^[a-zA-Z]{2,4}$", value);
        System.out.println("테스트 : " + result);
    }

    // username, email, fullname
    @Test
    public void user_username_test() throws Exception {
        String username = "ssar";
        boolean result = Pattern.matches("^[a-zA-Z0-9]{2,20}$", username);
        System.out.println("테스트 : " + result);
    }

    @Test
    public void user_fullname_test() throws Exception {
        String fullname = "메타코딩";
        boolean result = Pattern.matches("^[a-zA-Z가-힣]{1,20}$", fullname);
        System.out.println("테스트 : " + result);
    }

    @Test
    public void user_email_test() throws Exception {
        String fullname = "ssaraa@nate.com"; // ac.kr co.kr or.kr
        boolean result = Pattern.matches("^[a-zA-Z0-9]{2,10}@[a-zA-Z0-9]{2,6}\\.[a-zA-Z]{2,3}$", fullname);
        System.out.println("테스트 : " + result);
    }

    // ChatGPT에게 물어봄! [스프링부트에서 이메일 정규표현식 알려줘]
    @Test
    public void real_email_test() throws Exception {
        String email = "ssar@ac";
        boolean result = Pattern.matches("^[\\w._%+-]+@[\\w.-]+\\.[a-zA-Z]{2,6}$", email);
        System.out.println("테스트 : "+result);
    }

    @Test
    public void account_gubun_test1() throws Exception {
        String gubun = "DEPOSIT"; // ac.kr co.kr or.kr
        boolean result = Pattern.matches("^(DEPOSIT)$", gubun);
        System.out.println("테스트 : " + result);
    }

    @Test
    public void account_gubun_test2() throws Exception {
        String gubun = "TRANSFER"; // ac.kr co.kr or.kr
        boolean result = Pattern.matches("^(DEPOSIT|TRANSFER)$", gubun);
        System.out.println("테스트 : " + result);
    }

    @Test
    public void account_tel_test1() throws Exception {
        String tel = "010-3333-7777"; // ac.kr co.kr or.kr
        boolean result = Pattern.matches("^[0-9]{3}-[0-9]{4}-[0-9]{4}", tel);
        System.out.println("테스트 : " + result);
    }

    @Test
    public void account_tel_test2() throws Exception {
        String tel = "01033337777"; // ac.kr co.kr or.kr
        boolean result = Pattern.matches("^[0-9]{11}", tel);
        System.out.println("테스트 : " + result);
    }
}
```